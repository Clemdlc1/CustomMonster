package fr.custommobs.events.types;

import fr.custommobs.CustomMobsPlugin;
import fr.custommobs.api.PrisonTycoonHook;
import fr.custommobs.events.EventConfigManager;
import fr.custommobs.events.EventListener;
import fr.custommobs.managers.BossStatsManager;
import org.bukkit.*;
import org.bukkit.entity.LivingEntity;
import org.bukkit.entity.Player;
import org.bukkit.metadata.FixedMetadataValue;
import org.bukkit.scheduler.BukkitRunnable;

import java.util.*;
import java.util.concurrent.ThreadLocalRandom;

/**
 * √âv√©nement Contenir la Br√®che - Version am√©lior√©e avec localisations configurables
 */
public class BreachContainmentEvent extends ServerEvent {

    private final EventConfigManager configManager;
    private final BossStatsManager bossStatsManager;

    private final Map<UUID, Integer> mobKills = new HashMap<>();
    private final List<Location> activeBreaches = new ArrayList<>();
    private final Set<LivingEntity> spawnedMobs = new HashSet<>();

    private int totalMobsKilled = 0;
    private final int mobsToContain;
    private final int duration;
    private boolean breachesContained = false;

    public BreachContainmentEvent(CustomMobsPlugin plugin, PrisonTycoonHook prisonHook,
                                  EventListener.EventRewardsManager rewardsManager, EventConfigManager configManager,
                                  BossStatsManager bossStatsManager) {
        super(plugin, prisonHook, rewardsManager, "breach_containment", "Contenir la Br√®che",
                EventType.COOPERATIVE, configManager.getEventSchedule("breach_containment").getDuration());

        this.configManager = configManager;
        this.bossStatsManager = bossStatsManager;
        this.mobsToContain = calculateMobsToContain();
        this.duration = configManager.getEventSchedule("breach_containment").getDuration();
    }

    @Override
    protected void onStart() {
        // S√©lectionner les zones de br√®che depuis la configuration
        List<EventConfigManager.EventLocationConfig> breachAreas = getBreachAreas();
        if (breachAreas.isEmpty()) {
            plugin.getLogger().severe("¬ßcAucune zone de br√®che configur√©e ('breach-areas')! √âv√©nement annul√©.");
            forceEnd();
            return;
        }

        // S√©lectionner 2-4 zones de br√®che al√©atoirement
        int breachCount = ThreadLocalRandom.current().nextInt(2, Math.min(5, breachAreas.size() + 1));
        Collections.shuffle(breachAreas);

        for (int i = 0; i < breachCount; i++) {
            EventConfigManager.EventLocationConfig area = breachAreas.get(i);
            Location breachLocation = area.getRandomLocation(plugin); // <-- FIX 1
            if (breachLocation != null) {
                activeBreaches.add(breachLocation);
                createBreach(breachLocation, area.getDisplayName());
            }
        }

        if (activeBreaches.isEmpty()) {
            plugin.getLogger().severe("¬ßcImpossible de cr√©er des br√®ches! √âv√©nement annul√©.");
            forceEnd();
            return;
        }

        // Annonces
        Bukkit.broadcastMessage("¬ß5¬ßlüåÄ ALERTE BR√àCHE DIMENSIONNELLE ! üåÄ");
        Bukkit.broadcastMessage("¬ßd¬ßl" + activeBreaches.size() + " br√®ches d√©tect√©es !");
        Bukkit.broadcastMessage("¬ß7¬ßlObjectif: ¬ßcContenir ¬ß4" + mobsToContain + " entit√©s¬ß7!");
        Bukkit.broadcastMessage("¬ß7¬ßlLieux: " + getBreachLocationNames());

        // Programmer les vagues de monstres
        scheduleMonsterWaves();

        // Programmer les alertes de temps
        scheduleTimeAlerts();
    }

    /**
     * R√©cup√®re les zones de br√®che depuis la configuration
     */
    private List<EventConfigManager.EventLocationConfig> getBreachAreas() {
        // REFACTORED: Remove hardcoded logic and use the config manager
        return configManager.getEventLocationConfigs("breach-areas");
    }

    /**
     * Calcule le nombre de monstres √† contenir selon le nombre de joueurs
     */
    private int calculateMobsToContain() {
        int onlinePlayers = Bukkit.getOnlinePlayers().size();
        int baseMobs = configManager.getEventsConfig().getInt("event-settings.breach_containment.base-mobs", 30);
        int mobsPerPlayer = configManager.getEventsConfig().getInt("event-settings.breach_containment.mobs-per-player", 3);
        int playerThreshold = configManager.getEventsConfig().getInt("event-settings.breach_containment.player-threshold", 5);

        int additionalMobs = Math.max(0, (onlinePlayers - playerThreshold) * mobsPerPlayer);
        return baseMobs + additionalMobs;
    }

    /**
     * Cr√©e une br√®che √† l'emplacement sp√©cifi√©
     */
    private void createBreach(Location location, String areaName) {
        if (location.getWorld() == null) return;
        // Effets visuels de la br√®che
        location.getWorld().spawnParticle(Particle.PORTAL, location, 100, 3, 3, 3, 1.0);
        location.getWorld().spawnParticle(Particle.DRAGON_BREATH, location, 50, 2, 2, 2, 0.1);

        // Son dramatique
        for (Player player : location.getWorld().getPlayers()) {
            if (player.getLocation().distanceSquared(location) < 10000) { // 100 blocks
                player.playSound(location, Sound.ENTITY_ENDERMAN_SCREAM, 1.0f, 0.5f);
            }
        }

        plugin.getLogger().info("¬ß5[BR√àCHE] Br√®che cr√©√©e √† " + areaName +
                " (" + location.getBlockX() + ", " + location.getBlockY() + ", " + location.getBlockZ() + ")");
    }

    /**
     * R√©cup√®re les noms des localisations des br√®ches
     */
    private String getBreachLocationNames() {
        List<String> names = new ArrayList<>();
        for (int i = 0; i < activeBreaches.size(); i++) {
            names.add("Zone " + (i + 1)); // Placeholder name, could be improved
        }
        return String.join("¬ß7, ¬ße", names);
    }

    /**
     * Programme les vagues de monstres
     */
    private void scheduleMonsterWaves() {
        // Vagues programm√©es
        new BukkitRunnable() {
            int waveNumber = 1;

            @Override
            public void run() {
                if (!isActive() || breachesContained) {
                    cancel();
                    return;
                }
                spawnWave(waveNumber);
                waveNumber++;
            }
        }.runTaskTimer(plugin, 100L, 2400L); // Starts after 5s, then every 2 minutes
    }

    /**
     * Fait appara√Ætre une vague de monstres
     */
    private void spawnWave(int waveNumber) {
        List<EventConfigManager.EventMobConfig> breachMobConfigs = getBreachMobConfigs();
        if (breachMobConfigs.isEmpty()) {
            plugin.getLogger().warning("Aucun monstre de br√®che configur√© ('breach-mobs')!");
            return;
        }

        int mobsPerBreach = Math.min(8, 2 + waveNumber); // Starts at 3, caps at 8
        boolean isIntensive = waveNumber > 4;

        if (isIntensive) {
            Bukkit.broadcastMessage("¬ßc¬ßl[BR√àCHE] ¬ß4¬ßlVAGUE INTENSIVE " + (waveNumber - 4) + " ! Les br√®ches se d√©stabilisent !");
        } else {
            Bukkit.broadcastMessage("¬ß5¬ßl[BR√àCHE] ¬ßdVague " + waveNumber + " d√©tect√©e !");
        }

        for (Location breachLocation : activeBreaches) {
            spawnMobsAtBreach(breachLocation, mobsPerBreach, breachMobConfigs);
            if (isIntensive && breachLocation.getWorld() != null) {
                breachLocation.getWorld().spawnParticle(Particle.LAVA, breachLocation, 30, 2, 1, 2, 0);
            }
        }

        for (Player player : Bukkit.getOnlinePlayers()) {
            player.playSound(player.getLocation(), isIntensive ? Sound.ENTITY_RAVAGER_ROAR : Sound.ENTITY_ZOMBIE_VILLAGER_CURE, 1.0f, isIntensive ? 0.5f : 0.7f);
        }
    }

    /**
     * Fait appara√Ætre des monstres √† une br√®che
     */
    private void spawnMobsAtBreach(Location breachLocation, int mobCount, List<EventConfigManager.EventMobConfig> mobConfigs) {
        if (breachLocation.getWorld() == null) return;

        for (int i = 0; i < mobCount; i++) {
            EventConfigManager.EventMobConfig selectedMob = selectWeightedMob(mobConfigs);
            if (selectedMob == null) continue;

            double angle = ThreadLocalRandom.current().nextDouble() * 2 * Math.PI;
            double distance = 3 + ThreadLocalRandom.current().nextDouble() * 7;

            Location spawnLocation = breachLocation.clone().add(
                    Math.cos(angle) * distance,
                    1, // Spawn slightly above the ground
                    Math.sin(angle) * distance
            );

            try {
                LivingEntity mob = plugin.getMobManager().spawnCustomMob(selectedMob.getId(), spawnLocation);
                if (mob != null) {
                    mob.setMetadata("breach_mob", new FixedMetadataValue(plugin, true));
                    mob.setMetadata("breach_event_id", new FixedMetadataValue(plugin, getId()));
                    mob.setCustomNameVisible(true);
                    spawnedMobs.add(mob);
                    spawnLocation.getWorld().spawnParticle(Particle.PORTAL, spawnLocation.add(0, 1, 0), 20, 0.5, 0.5, 0.5, 0.5);
                }
            } catch (Exception e) {
                plugin.getLogger().warning("Erreur lors du spawn du monstre de br√®che " + selectedMob.getId() + ": " + e.getMessage());
            }
        }
    }

    private List<EventConfigManager.EventMobConfig> getBreachMobConfigs() {
        return configManager.getEventMobsInCategory("breach-mobs");
    }

    private EventConfigManager.EventMobConfig selectWeightedMob(List<EventConfigManager.EventMobConfig> mobs) {
        if (mobs.isEmpty()) return null;

        int totalWeight = mobs.stream().mapToInt(EventConfigManager.EventMobConfig::getSpawnWeight).sum();
        if (totalWeight <= 0) {
            return mobs.get(ThreadLocalRandom.current().nextInt(mobs.size()));
        }
        int randomWeight = ThreadLocalRandom.current().nextInt(totalWeight);

        int currentWeight = 0;
        for (EventConfigManager.EventMobConfig mob : mobs) {
            currentWeight += mob.getSpawnWeight();
            if (randomWeight < currentWeight) {
                return mob;
            }
        }
        return mobs.get(0); // Fallback
    }

    /**
     * Programme les alertes de temps
     */
    private void scheduleTimeAlerts() {
        int totalDuration = this.duration; // <-- FIX 2

        // Alerte √† la moiti√© du temps
        new BukkitRunnable() {
            @Override
            public void run() {
                if (isActive() && !breachesContained) {
                    int remaining = getRemainingMobs();
                    Bukkit.broadcastMessage("¬ße¬ßl[BR√àCHE] ¬ß7Mi-temps ! Encore ¬ßc" + remaining + " entit√©s¬ß7 √† contenir !");
                }
            }
        }.runTaskLater(plugin, (long) (totalDuration / 2) * 20L);

        // Alerte finale
        if (totalDuration > 300) {
            new BukkitRunnable() {
                @Override
                public void run() {
                    if (isActive() && !breachesContained) {
                        Bukkit.broadcastMessage("¬ßc¬ßl[BR√àCHE] ¬ß4¬ßlDERNI√àRES 5 MINUTES ! Les br√®ches vont se stabiliser !");
                        for (Player player : Bukkit.getOnlinePlayers()) {
                            player.playSound(player.getLocation(), Sound.BLOCK_END_PORTAL_SPAWN, 1.0f, 0.8f);
                        }
                    }
                }
            }.runTaskLater(plugin, (totalDuration - 300) * 20L);
        }
    }

    /**
     * G√®re la mort d'un monstre de br√®che
     */
    public void onMobKilled(LivingEntity mob, Player killer) {
        if (!spawnedMobs.remove(mob)) return;

        addParticipant(killer);
        mobKills.merge(killer.getUniqueId(), 1, Integer::sum);
        totalMobsKilled++;

        if (mob.getLocation().getWorld() != null) {
            mob.getLocation().getWorld().spawnParticle(Particle.SOUL_FIRE_FLAME, mob.getLocation().add(0, 1, 0), 10, 0.5, 0.5, 0.5, 0.05);
        }
        killer.playSound(killer.getLocation(), Sound.ENTITY_EXPERIENCE_ORB_PICKUP, 1.0f, 1.5f);

        int remaining = getRemainingMobs();
        if (remaining > 0) {
            if (remaining <= 10 || totalMobsKilled % 25 == 0) {
                Bukkit.broadcastMessage("¬ß5¬ßl[BR√àCHE] ¬ßd" + totalMobsKilled + "¬ß7/¬ßc" + mobsToContain + " ¬ß7entit√©s contenues");
            }
        } else {
            onBreachesContained();
        }
    }

    /**
     * G√®re la r√©ussite de l'√©v√©nement
     */
    private void onBreachesContained() {
        if (breachesContained) return;
        breachesContained = true;

        Bukkit.broadcastMessage("\n¬ßa¬ßlüéâ BR√àCHES CONTENUES ! üéâ");
        Bukkit.broadcastMessage("¬ß2¬ßlToutes les entit√©s ont √©t√© neutralis√©es !");
        Bukkit.broadcastMessage("¬ß7¬ßlParticipants: ¬ßf" + getParticipantCount() + "\n");

        closeAllBreaches();
        distributeRewards();

        new BukkitRunnable() {
            @Override
            public void run() {
                if (isActive()) {
                    forceEnd();
                }
            }
        }.runTaskLater(plugin, 400L); // 20 secondes
    }

    /**
     * Ferme toutes les br√®ches avec des effets
     */
    private void closeAllBreaches() {
        for (Location breachLocation : activeBreaches) {
            if (breachLocation.getWorld() == null) continue;
            breachLocation.getWorld().spawnParticle(Particle.REVERSE_PORTAL, breachLocation, 150, 2, 2, 2, 0.2);
            breachLocation.getWorld().playSound(breachLocation, Sound.ENTITY_GENERIC_EXPLODE, 0.7f, 1.5f);
        }
    }

    /**
     * Distribue les r√©compenses
     */
    private void distributeRewards() {
        EventConfigManager.EventRewardConfig rewards = configManager.getEventRewards("breach_containment");
        if (rewards == null) {
            plugin.getLogger().warning("Aucune configuration de r√©compense pour breach_containment");
            return;
        }

        int participationReward = rewards.getReward("participation");
        int bonusPerKill = rewards.getReward("bonus-per-kill");
        int topKillerBonus = rewards.getReward("top-killer-bonus");

        UUID topKillerId = mobKills.entrySet().stream()
                .max(Map.Entry.comparingByValue())
                .map(Map.Entry::getKey)
                .orElse(null);

        for (UUID participantId : getParticipants()) {
            Player participant = Bukkit.getPlayer(participantId);
            if (participant != null && participant.isOnline()) {
                double totalReward = participationReward;
                int kills = mobKills.getOrDefault(participantId, 0);
                totalReward += (double) kills * bonusPerKill;

                if (participantId.equals(topKillerId)) {
                    totalReward += topKillerBonus;
                    participant.sendMessage("¬ßa¬ßl[R√âCOMPENSE] ¬ß2Bonus: Meilleur chasseur de br√®che !");
                }

                if (totalReward > 0 && prisonHook != null) {
                    prisonHook.addCoins(participant, (long) totalReward);
                    participant.sendMessage("¬ß5¬ßl[BR√àCHE] ¬ß7R√©compense: ¬ßa" + String.format("%.0f", totalReward) + "¬ß7 pi√®ces (¬ßd" + kills + " kills¬ß7)");
                }
            }
        }
    }

    @Override
    protected void onEnd() {
        if (!breachesContained) {
            Bukkit.broadcastMessage("¬ßc¬ßl[BR√àCHE] ¬ß7Temps √©coul√©! Les br√®ches se stabilisent naturellement...");
            Bukkit.broadcastMessage("¬ß7¬ßl" + totalMobsKilled + "¬ß7/¬ßc" + mobsToContain + " ¬ß7entit√©s neutralis√©es.");
            closeAllBreaches();
            distributeFallbackRewards();
        }
        cleanupRemainingMobs();
    }

    private void distributeFallbackRewards() {
        EventConfigManager.EventRewardConfig rewards = configManager.getEventRewards("breach_containment");
        if (rewards == null || prisonHook == null) return;

        int participationReward = rewards.getReward("participation") / 2; // Reduced reward
        int bonusPerKill = rewards.getReward("bonus-per-kill");

        for (UUID participantId : getParticipants()) {
            Player participant = Bukkit.getPlayer(participantId);
            if (participant != null && participant.isOnline()) {
                int kills = mobKills.getOrDefault(participantId, 0);
                double totalReward = participationReward + ((double) kills * bonusPerKill);
                if (totalReward > 0) {
                    prisonHook.addCoins(participant, (long) totalReward);
                    participant.sendMessage("¬ß7¬ßl[BR√àCHE] ¬ß7R√©compense partielle: ¬ß7" + String.format("%.0f", totalReward) + "¬ß7 pi√®ces");
                }
            }
        }
    }

    private void cleanupRemainingMobs() {
        for (LivingEntity mob : spawnedMobs) {
            if (mob != null && !mob.isDead()) {
                mob.remove();
            }
        }
        spawnedMobs.clear();
    }

    @Override
    protected void onCleanup() {
        mobKills.clear();
        activeBreaches.clear();
        spawnedMobs.clear();
        breachesContained = false;
        totalMobsKilled = 0;
    }

    // GETTERS
    public int getRemainingMobs() {
        return Math.max(0, mobsToContain - totalMobsKilled);
    }
}